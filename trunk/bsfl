#!/bin/bash
# ###########################
# Bash Shell Function Library
# ###########################
#
# Author: Louwrentius <louwrentius@gmail.com>
#
# Copyright Â© 2010
#
# Released under the curren GPL version.
#
# Description:
#
# This is a shell script library. It contains functions that can be called by
# programs that include (source) this library. 
#
# By simply sourcing this library, you can use all available functions as 
# documented on the projects page.
#
#

BSFL_VERSION=1.20

#
# Do not edit this file. Just source it into your script
# and override the variables to change their value.
#

#
# Debug mode shows more verbose output to screen and log files.
# Value: yes or no (y / n)
#
DEBUG=no

# 
# Syslog style log messages
#
LOGDATEFORMAT="%b %e %H:%M:%S"
LOG_FILE=$0.log

#
# Enable / disable logging to a file
# Value: yes or no (y / n)
#
LOG_ENABLED=no

#
# Use colours in output.
#
RED="tput setaf 1"
GREEN="tput setaf 2"
YELLOW="tput setaf 3"
BLUE="tput setaf 4"
MAGENTA="tput setaf 5"
CYAN="tput setaf 6"
LIGHT_BLUE="$CYAN"
BOLD="tput bold"
DEFAULT="tput sgr0"

RED_BG="tput setab 1"
GREEN_BG="tput setab 2"
YELLOW_BG="tput setab 3"
BLUE_BG="tput setab 4"
MAGENTA_BG="tput setab 5"
CYAN_BG="tput setab 6"

#
# returns 0 if a variable is defined (set)
# returns 1 if a variable is unset
#
function defined {
    [[ ${!1-X} == ${!1-Y} ]]
}

#
# returns 0 if a variable is defined (set) and value's length > 0
# returns 1 otherwise
#
function has_value {
    if defined $1; then
        if [[ -n ${!1} ]]; then
            return 0
        fi
    fi
    return 1
}

#
# returns 0 if a directory exists
# returns 1 otherwise
#
function directory_exists {
    if [[ -d $1 ]]; then
        return 0
    fi
    return 1
}

#
# returns 0 if a (regular) file exists
# returns 1 otherwise
#
function file_exists {
    if [[ -f $1 ]]; then
        return 0
    fi
    return 1
}

#
# returns lowercase string
#
function tolower {
    echo "$1" | tr '[:upper:]' '[:lower:]'
}

#
# returns uppercase string
#
function toupper {
    echo "$1" | tr '[:lower:]' '[:upper:]'
}

#
# Only returns the first part of a string, delimited by tabs or spaces
#
function trim {
    echo $1
}

#
# Override this function if required.
#
show_usage () {
   
    MESSAGE="$1" 
    echo "$MESSAGE"
    exit 1
}


#
# The log funcion just puts a string into a file, prepended with a date & time in 
# syslog format.
#
log () {
    
    if has_value "LOG_FILE" && [[ "$LOG_ENABLED" == "yes" || "$LOG_ENABLED" == "y" ]]
    then
        LOG_MESSAGE="$1" 
        DATE=`date +"$LOGDATEFORMAT"`

        if has_value "LOG_MESSAGE"
        then
            echo "$DATE $LOG_MESSAGE" >> "$LOG_FILE"
        else
            echo "$DATE -- no log message received --" >> "$LOG_FILE"
        fi
    fi
}

msg () {

    MESSAGE="$1"
    COLOR="$2"

    if ! has_value COLOR
    then
        COLOR="$DEFAULT"
    fi
        

    if has_value "MESSAGE"
    then
        $COLOR
        echo "$MESSAGE" 
        $DEFAULT
        log "$MESSAGE"
    else
        echo "-- no message received --"
        log "$MESSAGE"
    fi
}

#
# This function echos a message 
# and displays the status at the end of the line.
#
msg_status () {

    MESSAGE="$1"
    STATUS="$2"

    msg "$MESSAGE"
    display_status "$STATUS"
}

#
# These functions are just short hand for messages like
# msg_status "this message is ok" OK
#

msg_ok () {

    MESSAGE="$1"
    STATUS="OK"
    msg_status "$MESSAGE" "$STATUS"
}

msg_not_ok () {

    MESSAGE="$1"
    STATUS="NOT_OK"
    msg_status "$MESSAGE" "$STATUS"
}

msg_fail () {

    MESSAGE="$1"
    STATUS="FAILED"
    msg_status "$MESSAGE" "$STATUS"
}

msg_info () {
    MESSAGE="$1"
    STATUS="INFO"
    msg_status "$MESSAGE" "$STATUS"
}

msg_warn () {

    MESSAGE="$1"
    STATUS="WARN"
    msg_status "$MESSAGE" "$STATUS"
}

#
# This is a function that just positions
# the cursor one row up and to the right.
# It then prints a message with specified
# Color
#
# ARG1 = "status message (OK / FAIL)"
# ARG2 = The color in which the status is displayed.
#
raw_status () {

    STATUS="$1"
    COLOR="$2"

    function position_cursor () {

        let RES_COL=`tput cols`-12
        tput cuf $RES_COL
        tput cuu1
    }

    position_cursor
    echo -n "["
    $DEFAULT
    $BOLD
    $COLOR
    echo -n "$STATUS"
    $DEFAULT
    echo "]"

}

display_status () {


    STATUS="$1"

    case $STATUS in 

    OK  ) 
            STATUS="  OK  "  
            COLOR="$GREEN"
            ;;
    NOT_OK)
            STATUS="NOT OK"
            COLOR="$RED"
            ;;

    PASSED ) 
            STATUS="PASSED"  
            COLOR="$GREEN"
            ;;

    SUCCESS ) 
            STATUS="SUCCESS"  
            COLOR="$GREEN"
            ;;
    
    FAILURE | FAILED | ERROR )
            STATUS="FAILED"  
            COLOR="$RED"
            ;;

    INFO | NOTICE )
            STATUS="NOTICE"  
            COLOR="$LIGHT_BLUE"
            ;;

    WARNING | WARN )
            STATUS=" WARN "  
            COLOR="$YELLOW"
            ;;
    *)
            STATUS="UNDEFINED"
            COLOR="$YELLOW"
    esac

    raw_status "$STATUS" "$COLOR"
}

check_status () {

    ERROR="$?"

    MSG_OK="$1"
    MSG_FAIL="$2"

    if [ "$ERROR" == "0" ]
    then
        if [ ! -z "$MSG_OK" ]
        then
            echo "$MSG_OK"
        fi
        display_status OK
        return 0
    else
        if [ ! -z "$MSG_FAIL" ]
        then
            echo "$MSG_FAIL"
        fi
        display_status FAILLURE
        return 1
    fi
}

bail () {

    ERROR="$?"
    MSG="$1"
    if [ ! "$ERROR" = "0" ]
    then
        msg_fail "$MSG"
        exit 1
    fi
}

cmd () {

    COMMAND="$1"
    log "Executing -- $COMMAND"

    RESULT=$($COMMAND 2>&1 )
    ERROR=$?

    if [ "$ERROR" == "0" ]
    then
        msg_ok "Command -- ${COMMAND:0:20}... -- executed ok."
        if [ "$DEBUG" == "1" ]
        then
            msg "$RESULT"
        fi
    else
        msg_fail "Command -- ${COMMAND:0:20}... -- execution failed."
    fi

    return "$ERROR"
}

start_watch () {

   echo $(date +%s)
}

stop_watch () {
    
    START="$1"
    STOP="$(date +%s)"

    echo $(( STOP - START ))
}

# Prints an error message ($2) to stderr and exits with the return code ($1).
function die {
    local -r err_code="$1"
    local -r err_msg="$2"
    local -r err_caller="${3:-$(caller 0)}"

    echo "ERROR: $err_msg"
    echo "ERROR: At line $err_caller"
    echo "ERROR: Error code = $err_code"
    exit "$err_code"
} >&2 # function writes to stderr

# Check if a return code ($1) indicates an error (i.e. >0) and prints an error
# message ($2) to stderr and exits with the return code ($1).
function die_if {
    local -r err_code=$1
    local -r err_msg=$2
    local -r err_caller=$(caller 0)

    if (( err_code )); then
        die $err_code "$err_msg" "$err_caller"
    fi
} >&2 # function writes to stderr




